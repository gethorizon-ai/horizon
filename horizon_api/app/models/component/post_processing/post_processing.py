"""Data structure to track post-processing operations."""

from app.models.llm.base import BaseLLM
from app.models.parser.pydantic_output_parser import PydanticOutputParser
from app.models.parser.retry_with_error_output_parser import RetryWithErrorOutputParser
from app.utilities.S3.s3_util import download_file_from_s3_and_save_locally
from app.utilities.output_schema import output_schema
from langchain.prompts.base import StringPromptValue  # TODO: create internal wrapper
import copy
import re
import json


# Final output value if unable to align llm output with output schema requirements
FINAL_ERROR_MESSAGE = (
    "Error - failed to generate output satisfying output schema requirements."
)


class PostProcessing:
    """Data structure to track post-processing operations."""

    def __init__(self, pydantic_model_s3_key: str, llm: BaseLLM = None):
        """Initializes PostProcessing data structure.

        Args:
            pydantic_model_s3_key (str): s3 key for pydantic model of output schema.
            llm (BaseLLM, optional): LLM object to use when retrying with output errors. Defaults to None.
        """
        self.pydantic_object = output_schema.get_pydantic_object_from_s3(
            pydantic_model_s3_key=pydantic_model_s3_key
        )
        self.pydantic_output_parser = PydanticOutputParser(
            pydantic_object=self.pydantic_object
        )
        self.output_format_instructions = (
            self.pydantic_output_parser.get_format_instructions()
        )

        # Initialize RetryWithErrorOutputParser if llm object provided
        self.retry_with_error_output_parser = None
        if llm:
            self.retry_with_error_output_parser = RetryWithErrorOutputParser.from_llm(
                parser=self.pydantic_output_parser, llm=llm
            )

    def update_llm_for_retry_with_error_output_parser(self, llm: BaseLLM):
        """Update or initialize RetryWithErrorOutputParser using provided llm object.

        Args:
            llm (BaseLLM): LLM object to use when retrying with output errors.
        """
        # Copy inputted llm and set temperature to 0 (to aid with error correction)
        llm_copy = copy.deepcopy(llm)
        llm_copy.set_temperature(temperature=0)

        # Add retry_with_error_output_parser
        self.retry_with_error_output_parser = RetryWithErrorOutputParser.from_llm(
            parser=self.pydantic_output_parser, llm=llm_copy
        )

    def parse_and_retry_if_needed(
        self, original_output: str, prompt_string: str
    ) -> str:
        """_summary_

        Args:
            original_output (str): original output string from llm.
            prompt_string (str): original prompt string used to call llm.

        Raises:
            ValueError: raises error if output generated by llm does not satisfy output schema requirements.
            ValueError: raises error if output generated by llm does not satisfy output schema requirements.

        Returns:
            str: output string satisfying output schema requirements.
        """
        print(f"Original output: {original_output}")
        # Clean output by escaping invalid JSON control characters (e.g., newlines)
        cleaned_output = PostProcessing.escape_invalid_json_control_characters(
            text=original_output
        )
        print(f"Cleaned output: {cleaned_output}")
        json.loads(cleaned_output)
        print("Successfully loaded cleaned output")
        self.pydantic_output_parser.parse(
            text=cleaned_output,
        )
        print("Successfully parsed cleaned output")

        # If retry_with_error_output_parser is setup, then try parsing with it. Enables 1 retry currently
        if self.retry_with_error_output_parser:
            try:
                prompt_value = StringPromptValue(text=prompt_string)
                print("Converted to StringPromptValue")
                parsed_output = self.retry_with_error_output_parser.parse_with_prompt(
                    completion=cleaned_output,
                    prompt_value=prompt_value,
                )
                return parsed_output.json()
            except:
                raise ValueError(FINAL_ERROR_MESSAGE)
        # If retry_with_error_output_parser is not setup, then try parsing output directly with no retry
        else:
            try:
                parsed_output = self.pydantic_output_parser.parse(
                    text=cleaned_output,
                )
                return parsed_output.json()
            except:
                raise ValueError(FINAL_ERROR_MESSAGE)

    def escape_invalid_json_control_characters(text: str) -> str:
        """Helper function that escapes invalid control characters from structured text from llm.

        Args:
            text (str): text from which to escape invalid control characters.

        Returns:
            str: updated text without invalid control characters.
        """
        # Greedy search for 1st json candidate.
        match = re.search(
            r"\{.*\}", text.strip(), re.MULTILINE | re.IGNORECASE | re.DOTALL
        )
        json_str = ""
        if match:
            json_str = match.group()

        # First load json_str with strict=False, then use JSON dumps to convert back to string while escaping control characters
        return json.dumps(json.loads(json_str, strict=False))
